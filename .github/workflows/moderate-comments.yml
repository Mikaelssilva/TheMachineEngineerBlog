name: Moderate Giscus Comments
on:
  discussion_comment:
    types: [created]

jobs:
  moderate:
    runs-on: ubuntu-latest
    steps:
      - name: Check for bad words
        uses: actions/github-script@v6
        with:
          script: |
            // Palavras proibidas (strings simples)
            const badWords = [
              // Racismo
              'macaco', 'negrinho', 'branquelo', 'judeu doente', 'cabelo de bombril', 'servi√ßo de preto',
              
              // LGBTfobia
              'veado', 'bicha', 'sapat√£o', 'viadinho', 'aid√©tico', 'frutinha', 'boiola',
              
              // Machismo
              'vai lavar lou√ßa', 'lugar de mulher √©', 'feminazi', 'puta', 'cad√™ o sandu√≠che',
              
              // Outros
              'deficiente mental', 'retardado', 'vai se matar', 'corno', 'gordo nojento',
              
              // Termos disfar√ßados (como strings)
              'v3@d0', 'b1ch4', 'm@c4c0'
            ];
            
            // Padr√µes regex para termos mais complexos
            const regexPatterns = [
              /n[e3]gr[o0]/i,
              /[ck]retin[o0]/i,
              /v[i1][a@]d[o0]/i,
              /b[i1]ch[a@]/i
            ];
            
            // Obt√©m o texto do coment√°rio
            const commentText = context.payload.comment.body;
            const commentTextLower = commentText.toLowerCase();
            
            console.log('Verificando coment√°rio:', commentText);
            
            let hasProhibitedContent = false;
            let matchedWord = '';
            
            // Verifica palavras proibidas (strings)
            for (const word of badWords) {
              if (commentTextLower.includes(word.toLowerCase())) {
                hasProhibitedContent = true;
                matchedWord = word;
                break;
              }
            }
            
            // Verifica padr√µes regex
            if (!hasProhibitedContent) {
              for (const pattern of regexPatterns) {
                if (pattern.test(commentText)) {
                  hasProhibitedContent = true;
                  matchedWord = pattern.toString();
                  break;
                }
              }
            }
            
            if (hasProhibitedContent) {
              console.log('Conte√∫do proibido encontrado:', matchedWord);
              
              try {
                // Deleta o coment√°rio
                await github.rest.discussions.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_number: context.payload.comment.number
                });
                
                console.log('Coment√°rio deletado com sucesso');
                
                // Opcional: Cria um novo coment√°rio informativo
                // (Note: isso criar√° um coment√°rio que pode tamb√©m ser moderado)
                await github.rest.discussions.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  discussion_number: context.payload.discussion.number,
                  body: 'üö® Um coment√°rio foi removido automaticamente por violar nossas diretrizes da comunidade. Por favor, mantenha um ambiente respeitoso para todos.'
                });
                
                console.log('Coment√°rio de notifica√ß√£o criado');
                
              } catch (error) {
                console.error('Erro ao moderar coment√°rio:', error);
                
                // Se falhar, pelo menos registra o problema
                core.setFailed(`Falha na modera√ß√£o: ${error.message}`);
              }
            } else {
              console.log('Coment√°rio aprovado - nenhum conte√∫do proibido encontrado');
            }
          github-token: ${{ secrets.GITHUB_TOKEN }}
