name: Moderate Giscus Comments
on:
  discussion_comment:
    types: [created]

jobs:
  moderate:
    runs-on: ubuntu-latest
    steps:
      - name: Check for bad words
        uses: actions/github-script@v6
        with:
          script: |
            // Palavras proibidas (strings simples)
            const badWords = [
              // Racismo
              'macaco', 'negrinho', 'branquelo', 'judeu doente', 'cabelo de bombril', 'servi√ßo de preto',
              
              // LGBTfobia
              'veado', 'bicha', 'sapat√£o', 'viadinho', 'aid√©tico', 'frutinha', 'boiola',
              
              // Machismo
              'vai lavar lou√ßa', 'lugar de mulher √©', 'feminazi', 'puta', 'cad√™ o sandu√≠che',
              
              // Outros
              'deficiente mental', 'retardado', 'vai se matar', 'corno', 'gordo nojento',
              
              // Termos disfar√ßados (como strings)
              'v3@d0', 'b1ch4', 'm@c4c0'
            ];
            
            // Padr√µes regex para termos mais complexos
            const regexPatterns = [
              /n[e3]gr[o0]/i,
              /[ck]retin[o0]/i,
              /v[i1][a@]d[o0]/i,
              /b[i1]ch[a@]/i
            ];
            
            // Obt√©m o texto do coment√°rio
            const commentText = context.payload.comment.body;
            const commentTextLower = commentText.toLowerCase();
            
            console.log('Verificando coment√°rio:', commentText);
            
            let hasProhibitedContent = false;
            let matchedWord = '';
            
            // Verifica palavras proibidas (strings)
            for (const word of badWords) {
              if (commentTextLower.includes(word.toLowerCase())) {
                hasProhibitedContent = true;
                matchedWord = word;
                break;
              }
            }
            
            // Verifica padr√µes regex
            if (!hasProhibitedContent) {
              for (const pattern of regexPatterns) {
                if (pattern.test(commentText)) {
                  hasProhibitedContent = true;
                  matchedWord = pattern.toString();
                  break;
                }
              }
            }
            
            if (hasProhibitedContent) {
              console.log('Conte√∫do proibido encontrado:', matchedWord);
              
              try {
                // Obt√©m o node_id do coment√°rio para usar com GraphQL
                const commentNodeId = context.payload.comment.node_id;
                
                // Deleta o coment√°rio usando GraphQL
                const deleteResult = await github.graphql(`
                  mutation deleteDiscussionComment($commentId: ID!) {
                    deleteDiscussionComment(input: {id: $commentId}) {
                      clientMutationId
                    }
                  }
                `, {
                  commentId: commentNodeId
                });
                
                console.log('Coment√°rio deletado com sucesso via GraphQL');
                
                // Cria um novo coment√°rio informativo usando GraphQL  
                const discussionNodeId = context.payload.discussion.node_id;
                
                await github.graphql(`
                  mutation addDiscussionComment($discussionId: ID!, $body: String!) {
                    addDiscussionComment(input: {
                      discussionId: $discussionId,
                      body: $body
                    }) {
                      comment {
                        id
                      }
                    }
                  }
                `, {
                  discussionId: discussionNodeId,
                  body: 'üö® **Coment√°rio removido automaticamente**\n\nUm coment√°rio foi removido por violar nossas diretrizes da comunidade. Por favor, mantenha um ambiente respeitoso para todos.\n\n---\n*Esta √© uma a√ß√£o autom√°tica do sistema de modera√ß√£o.*'
                });
                
                console.log('Coment√°rio de notifica√ß√£o criado via GraphQL');
                
              } catch (error) {
                console.error('Erro ao moderar coment√°rio:', error);
                
                // Fallback: Pelo menos registra o problema nos logs do GitHub
                console.log('Tentando alternativa: criar issue para revis√£o manual');
                
                try {
                  // Cria uma issue para revis√£o manual como fallback
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: 'üö® Modera√ß√£o Manual Necess√°ria',
                    body: `**Coment√°rio com conte√∫do proibido detectado:**
                    
**Autor:** @${context.payload.comment.user.login}
**Discussion:** #${context.payload.discussion.number}
**Palavra encontrada:** ${matchedWord}
**Data:** ${new Date().toISOString()}

**Coment√°rio original:**
\`\`\`
${context.payload.comment.body}
\`\`\`

**A√ß√£o necess√°ria:** Revisar e moderar manualmente.
**Link:** ${context.payload.comment.html_url}`,
                    labels: ['moderation', 'automated']
                  });
                  
                  console.log('Issue de modera√ß√£o manual criada');
                } catch (issueError) {
                  console.error('Falha ao criar issue de fallback:', issueError);
                }
                
                // Marca como falha para alertar nos logs
                core.setFailed(`Falha na modera√ß√£o autom√°tica: ${error.message}`);
              }
            } else {
              console.log('Coment√°rio aprovado - nenhum conte√∫do proibido encontrado');
            }
          github-token: ${{ secrets.GITHUB_TOKEN }}
